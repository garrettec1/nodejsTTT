This text file is for organizing my thoughts.
* Getting started
** Initial Goal
   - Make the game playable by two human players
   - Needs
     1. A board object
     2. A player object
     3. A game loop

** Board object
   - The most logical place to start working on a TTT game is the board.
   - Start by making the board display
     - Board object responds to display message, or always displays?
   - I am going to make it an object that responds to move messages.
     1. (some move)
        - From game, or player?
     2. returns
        - updated board
        - is move legal?
        - winning move?
*** data structure of game state
   - The display of the board is intimately related to how I am going to store
     and the state of the game pieces.
**** dictionary/map
     - Previously I have done this by using a dictionary (map) and format
       strings to get the game pieces displayed properly. Let's see if I can think
       of another way.
     - The convenience of this was that the board location was also the key value.
     - Since any function in the game could access this, it simplified the
       interface.
**** All encompesing array
     - I could make an array that held the board state and the disply
     - do something like var array = ['X', '|' , ' ', '|', 'O', '\n] ...
       then build a string out of it.
     - I don't think this is a good idea because it marries the display and the
       data in a gnarly way. Also hard to read.
**** Bisectional array.
     - Use a simple array to hold board state initialized with ' ' in each index.
     - Important note* access should be abstracted, responisibility of ... board.
     - Math to access.
       * coordinates denote shifts in index.
       * '1a'
       * the first int adds index like this index = (coord - 1)*3 and so on
       * the string index (if a -> index +0) (if b -> index +1) and so on
     - How to print board in this case?
     - how about something like console.log(" ", array(0), " | ", array(1)...
       and so on.
*** taking moves
    - So a message is going to be passed from ? (somewhere) to the Game_Board
      asking to make a move.
    - first step is to get it to take a move.
    - I think it is the responsibility of the player object to know what piece
      it is playing with, so that will be passed in.
    - What will be passed? Let's only worry about humans for now, since that is
      what I am working on. A string like '1a' will be passed.
    - This will want some private helper functions at some point. Need to look
      into how to do that in NodeJS. Looks like a convention thing.
**** Why is interpretation of move string a responsibility of Game_Board?
     - I could make a fairly solid argument that the player object should pass
       an index that directly relates to the board.
     - I chose not to do this for one primary reason.
     - I don't want the player object to have too much information about the
       game board. If I end up making changes to the data structure of board,
       I don't want those changes to also break Player. It is reasonable for
       Game_Board to be responsible for translating "1c" to index 2.
     - Complications?
       1. I am a little concerned about how the AI is going to interact with
          Game_Board. It is going to be interesting to figure that out.
**** Dealing with invalid moves
     - Given that Game_Board has all of the information about the state of the
       game, I think it is obvious that the responsibility for checking the
       legality of a move rests within Game_Board.
     - This begs the question: How will the interface operate.
     - In general, one does not want to expose too many elements to other
       objects.
     - Therefor I think that check move will be a helper function called by
       make_move.
     - I will alter make_move to return a boolean value. If false they Player
       object will have the responsibility of asking again for a move.
* Implementing Testing
  I am currently attempting to implement an automated testing framework for my
  game. This is something I have never attempted before, but I think that TDD
  is a really important idea. Installation of Mocha and Unit.js seems successful.
  I am struggling with actually implementing some automated tests.
  I might need to seek some advice.
* Second Goals
  The game can now store the state of the board, display the board, and take
  moves. What next?
  Getting the game playable.
  1. I need a player object. (this will require some thought)
  2. The game needs to be able to detect win's and tie's.
  3. Seriously. Automated testing. Needed.
  4. Replay?
** Player Object
   Eventually the player object will be able to take two parameters.
   1. Human or computer
   2. X or O
   Where X's move first.
   So I should build the player to default to human, but leave space for that
   to be changed later.
** Should I have a Game object?
* Testing issues
** issues with testing _is_move_empty
   - Oddly the code works fine, but testing it in my automated tests is proving
     complicated.
   - I need to fill a board to test the function, but I need to call make_move
     to fill the board.
   - I could provide access to the board with a setter, but that idea makes my
     skin crawl.
   - It seems like the idea should be to reduce the complexity of make move in
     order to make testing it's bits easier.
   - Removing the responsibilty for translating moves will reduce complexity.
     I can give that responsibility to the Player class?
*** Thoughts on solution:
    - The test I wrote for _is_move_index_empty depends on make_move working.
      This is problematic.
    - I need some automated way to create a board filled with arbitrary
      pieces. I will need this type of thing to test for winning moves and such.
    - Should I make some kind of mock object, or build objects and make moves...
      I really have no idea.
** Struggling with test first.
   - I am not ready. I am still trying to learn how to object orient, and I am
     having a hard time reconciling that with writing tests first.
   - Unit testing: I think writing unit tests as I write code is probably a fair
     spot to start at.
* Implementing the Game.
** getting input from user.
   - WOW. Getting user input from the console is more complicated than I
     expected.
   - I am trying to model it in a way that causes it to behave as if it
     were running syncronously not asynch.
   - The flow is a bit awkward to conceptualize.
     1. Game calls Player ask_move:
     2. Player asks a move which returns a string.
     3. String is now in Game:
     4. Game calls Player find_index(move)
     5. Player returns a move index to game
     6. Game calls Game_Board make_move(index)
        + Returns true if the move is made
        + Returns false if move cannot be made.
     7. If false Game (prints a message?) and calls ask_move
   - See. Having Game as the intermediary is increasing complexity.
